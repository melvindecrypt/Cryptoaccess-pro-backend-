look at the ending of the prompt that part that it states that "Admin dashboard (secured route, not part of this frontend scope" remove the not part of this frontend scope part.

======================

 I need a complete implementation of full language selection support for my Binance-style web application. Please follow these detailed steps:
> 
1. First-Time Language Selection Modal:
 * On the very first visit to the application (when no language preference is stored), display a modal to the user prompting them to select their preferred language.
 * This modal must be visually consistent with Binance's UI style (consider aspects like typography, color scheme, modal structure, and overall feel).
 * The modal should contain a scrollable list of language options. Each option in the list should display the language name using its native script as provided below:
   * Tamazight (ⵜⴰⵎⴰⵣⵉⵖⵜ)
   * Arabic (العربية)
   * English
   * Spanish (Español)
   * Persian (فارسی)
   * Korean (한국어)
   * French (Français)
   * German (Deutsch)
   * Italian (Italiano)
   * Portuguese (Português)
   * Hindi (हिन्दी)
   * Chinese (中文)
   * Bengali (বাংলা)
   * Russian (русский язык)
   * Japanese (日本語)
   * Urdu (اردو)
   * Indonesian (Bahasa Indonesia/Bahasa Melayu)
   * Marathi (मराठी)
   * Telugu (తెలుగు)
   * Vietnamese (Tiếng Việt)
   * Turkish (Türkçe)
   * Tamil (தமிழ்)
   * Gujarati (ગુજરાતી)
   * Malayalam (മലയാളം)
   * Kannada (ಕನ್ನಡ)
   * Odia (ଓଡ଼ିଆ)
   * Punjabi (ਪੰਜਾਬੀ)
   * Swahili (Kiswahili)
   * Ukrainian (українська мова)
   * Polish (Polski)
   * Yoruba (Yorùbá)
   * Igbo (Igbo)
   * Hausa (Hausa)
   * Filipino (Filipino)
   * Uzbek (Oʻzbek tili)
   * Amharic (አማርኛ)
   * Oromo (Afaan Oromoo)
   * Somali (Af Soomaali)
   * Nepali (नेपाली)
   * Sinhala (සිංහල)
   * Khmer (ភាសាខ្មែរ)
   * Pashto (پښتو)
   * Tajik (тоҷикӣ)
Frontend makes a PATCH request to /api/users/settings with the selected language code in the body.
 * The modal should have a clear way for the user to select a language and confirm their choice (e.g., by clicking on a language option or a "Confirm" button).
 * The modal should be fully responsive and mobile-friendly.
2. Saving Language Preference:
 * When the user selects a language and confirms, save a unique, lowercase English key for the selected language (e.g., "tamazight", "arabic", "english", "spanish", etc.) into the browser's localStorage under the key selectedLanguage.
3. language.js File Generation:
 * Create a JavaScript file named language.js.
 * This file should export a JavaScript object named languageOptions.
 * The languageOptions object should map each lowercase English key (as used in localStorage) to its corresponding native language name (as listed in step 1).
   // Example content of language.js
export const languageOptions = {
  tamazight: 'Tamazight (ⵜⴰⵎⴰⵣⵉⵖⵜ)',
  arabic: 'Arabic (العربية)',
  english: 'English',
  spanish: 'Spanish (Español)',
  // ... all other languages
};

4. translations.js File Generation:
 * Create a JavaScript file named translations.js.
 * This file should export a JavaScript object named translations.
 * The translations object will contain keys representing text elements in the app (e.g., "login", "signup", "welcome", "deposit", "withdraw").
 * For each key, provide translations in at least the following sample languages, using the lowercase English language keys as the top-level keys:
   // Example content of translations.js
export const translations = {
  english: {
    login: 'Log In',
    signup: 'Sign Up',
    welcome: 'Welcome',
    deposit: 'Deposit',
    withdraw: 'Withdraw',
    // ... more English translations
  },
  arabic: {
    login: 'تسجيل الدخول',
    signup: 'اشتراك',
    welcome: 'مرحباً',
    deposit: 'إيداع',
    withdraw: 'سحب',
    // ... more Arabic translations
  },
  french: {
    login: 'Se connecter',
    signup: 'S\'inscrire',
    welcome: 'Bienvenue',
    deposit: 'Déposer',
    withdraw: 'Retirer',
    // ... more French translations
  },
  // ... you will add translations for other languages later
};

5. Dynamic Text Display:
 * Upon loading the application, check if localStorage contains a value for selectedLanguage.
 * If it does, use this value to dynamically look up the appropriate translation from the translations object to display text across the application. For example, if selectedLanguage is "arabic", the text for the "login" button should be translations.arabic.login.
 * If localStorage does not contain a value for selectedLanguage, display the language selection modal (as described in step 1).
6. Subsequent Visits:
 * On subsequent visits after a language has been selected and saved in localStorage, the language selection modal should not appear automatically. After successful authentication, the frontend makes a GET request to /api/users/settings to fetch the user's preferred language from the backend.
    If the language fetched from the backend is different from the one in localStorage, the frontend should update its state and potentially localStorage to ensure consistency.The application should directly use the language preference stored in localStorage to display the translated text.
7. Language Switching Mechanism:
 * A mechanism for users to change their selected language after the initial selection. This could be a dropdown menu or a similar UI element in the app's settings or navigation. If you include this, the selection should update the selectedLanguage in localStorage and refresh the UI with the new translations.Frontend makes a PATCH request to /api/users/settings to update the user's language preference on the backend.


==================================


Main app pages 
 Landing Page (/): This is the initial page users will see, showcasing the app's features and encouraging them to sign up. It includes the Hero Section, "WHAT WE OFFER," testimonials, etc.
 * Signup (/signup): Users who click "Get Started" or the "Signup" link in the navigation will land on this page to create a new account.
 * Email Verification (Implied): After submitting the signup form, the user will likely see a temporary page or message instructing them to check their email for a verification link. This isn't a dedicated page they stay on for long, but a crucial step in the process.
 * Login (/login): Existing users or those who have verified their email will use this page to log in to their account.
 * Access Fee (/access-fee): New users who have logged in will be directed to this page to pay the one-time $99.90 access fee to unlock the main features of the app.
 * Main Dashboard (/dashboard): Once the access fee is paid (and likely confirmed by the admin in the backend), users will land on their personalized dashboard. This is the central hub where they can see their wallet balances and navigate to other features.
 * Exchange (/exchange): From the dashboard, users can navigate to the exchange section to simulate trading various crypto pairs.
 * Investments (/dashboard > Investments Tab or /investments): Pro+ users (after upgrading and admin approval) will be able to access the investments tab or a dedicated investments page to participate in simulated investment plans.
 * Charts (/charts?coin=...): Users can navigate to a specific chart view for different cryptocurrencies, often by clicking on a coin in their wallet overview.
 * Deposit (/dashboard > Deposit or /deposit): Users can access a page to view the admin's wallet addresses for various cryptocurrencies if they wish to send real payments.
 * Withdraw (/withdraw): Pro+ users who have completed KYC can access the withdrawal page to make simulated withdrawal requests.
 * Settings (/settings): Users can access their settings to manage their profile, language, KYC status, and other preferences.
 * Profile Edit (/profile/edit): Within the settings, users can navigate to edit their personal profile information.
 * KYC Verification (/kyc): Users can access the KYC verification page through the settings to upload their identification documents.
 * Pro+ Upgrade (/pro-plus): Users can navigate to this page to pay the one-time fee to upgrade to the Pro+ tier.
 * Referrals (/settings > Referrals Tab or /referrals): Users can access their referral information and sharing options.
 * Logout (within user dropdown in the header): When a user is finished, they will typically use a logout option in a user dropdown menu (usually in the top right of the header) to securely log out of the application.


===≈================================


Prompt for Bolt.new:

> Create a modal on the access fee payment and Pro+ subscription screens labeled "Upload Payment Proof". This modal should include:

A file upload input labeled "Upload Screenshot/Receipt".

A submit button labeled "Submit Proof" that sends a POST request to /api/payments/upload-proof with the file (key: proof) using multipart/form-data.

On success, show a toast: "Proof uploaded. Pending verification."


Ensure that this file upload is compatible with the existing backend that stores files locally (uploads/paymentProofs) and links uploads to the logged-in user.

Also create a dedicated section inside the Admin Panel for viewing all uploaded proofs. Use /api/payments/admin/proofs to list them with:

User email

Uploaded file (previewable or downloadable)

Status (pending/approved/rejected)

A dropdown to change status, which sends a PUT request to /api/payments/admin/proofs/:id with { status }.


===============================
Areas for Potential Clarification or Consideration (Minor Points):
 * Visual Reference ("Attached Image"): The prompt frequently mentions "Use the attached image as the exact visual reference for the homepage design" and to "maintain and Match the colors, font sizes, spacing, icons, and visual layout...including the placement of any images that were likely present in the original design." In a real-world scenario, the developer would absolutely need this image. Since I am an AI, I cannot see this image. For a developer, this would be the primary guide for the homepage's look and feel.
 * Frontend Framework (Next.js vs. React.js + Vite):
   * The initial line says: "Use Next.js, Tailwind CSS, and ShadCN/UI components..."
   * Later, for "Main User Side," it says "(Frontend: React.js + Vite)".
   * Next.js is a React framework. Vite can also be used with React. This isn't necessarily a contradiction, as a project might use Next.js for some parts (like public-facing pages for SEO) and Vite for a client-rendered dashboard, or it might be a slight overlap in specification. It would be good to clarify if the entire user-facing application should be built with Next.js, or if Vite is intended for a specific part (e.g., the secure dashboard panel). Given ShadCN/UI is often used with Next.js, leaning towards Next.js for the whole user-facing app seems likely.
 * Simulated Live Chart Data Source:
   * For the /exchange tab, it states: "Use CoinGecko’s public API to fetch the current market price every 5–10 seconds. Generate a fake dataset of chart points that fluctuates slightly around the current price..." This is a clear instruction for one part.
   * For the /dashboard > Charts Tab, it says: "Static Data Only... Fake line/bar charts for BTC, ETH, etc... Random historical data." This is also clear.
   * The distinction is good, just ensuring the developer applies the correct approach to the correct section.
 * Local Storage for KYC Uploads: "KYC uploads should be stored locally (no cloud)." This is a very important security/privacy consideration. "Locally" here likely means on the admin's system after being transmitted, or perhaps temporarily on the client before secure transmission if the backend handles it. For the frontend, it means facilitating the upload to the designated (presumably secure) backend endpoint. The frontend itself wouldn't permanently store KYC documents. The backend being complete implies it has a mechanism for receiving and managing these.
 * "Real wallet addresses must appear clearly where required": This is well-stated and the addresses are provided, which is good.
 * Admin Side Out of Scope: The prompt clearly states, "Admin dashboard (secured route, not part of this frontend scope)" and later "Admin Side (Admin Panel Overview)... All /admin/* routes are protected...". However, it then details the Admin UI Design Requirements and Functional Specs extensively. While useful for context (understanding what the frontend is interacting with from an admin perspective), a frontend developer might initially be confused if they should be building any part of this. Reconfirming that absolutely no admin UI is to be built by the frontend developer for this specific task would be good, though the backend handling is already confirmed. The detailed admin specs seem more like a design document for the existing backend's admin panel.
What I Think (Summary):
This prompt is exceptionally well-crafted for a frontend developer. It's detailed, clear, and provides a strong vision for the application. A developer receiving this would have a very solid understanding of what needs to be built. The primary missing piece for actual execution would be the visual reference image. The minor point about Next.js vs. Vite is easily clarified.
If this prompt were given to a frontend developer along with the mentioned visual assets and API documentation for the existing backend, they would be well-equipped to build CryptoAccess Pro to the desired specifications. It demonstrates a good understanding of the product and the information a developer needs.


solution 
change that react.js plus vite to next.js only answer specify that it would be used to build the entire app
you can add vite to the admin Side for the creation of the secure panel

read and merge this part 

This project involves building the complete frontend for a cryptocurrency application, CryptoAccess Pro, using the Bolt.New platform. This includes both the user-facing side and a secure administrator panel for managing user access and payment approvals. The backend, built with Node.js, is already complete and provides API endpoints that this frontend will consume.

API Communication: Utilize Bolt.New's built-in tools or any custom code capabilities it offers to make HTTP requests to the existing Node.js backend API endpoints.
II. Key Principles:
 * Backend Integration: The primary task is to build the frontend to connect seamlessly with the pre-existing Node.js backend API for both user and admin functionalities.
 * Simulation Focus (User Side): Cryptocurrency trading, balances, and investments within the user frontend are simulations. Real payments will be directed to the provided admin wallet addresses but the frontend's representation of these is for user access unlocking and Pro+ upgrades.
 * Real Wallet Addresses: Ensure the provided real wallet addresses appear clearly on the /deposit page.

======================

these are the endpoint apis to connect the frontend to the backend 

1. Signup Page (/signup)
Purpose:
Allows a new user to register an account.
HTTP Method:
POST
Endpoint URL:
https://cryptoaccesspro-backend.onrender.com/api/auth/register
Authentication:
No authentication required.
Request Data (JSON):
{ "email": "string (valid email format)", "password": "string (min 12 characters, at least one uppercase letter and number)", "referralCode": "string (optional, 8 characters if provided)" } 
Response Data (Success - JSON):
{ "message": "Registration successful. Check your email to verify.", "user": { "email": "string", "walletId": "string (UUIDv4)", "referralCode": "string", "kycStatus": "pending" } } 
Error Handling:
• 400: Missing or invalid input (e.g., email format, weak password)
• 409: Email already exists
• 500: Server error
The frontend should show relevant error messages using modals or inline form validation.
Data Types:
• email: string
• password: string
• referralCode: string (optional)
Sequential Calls:
• After this call, a follow-up email verification process is triggered.
• Frontend should redirect to a "verify your email" notice page.

2. Login Page (/login)
Purpose:
Allows a registered user to log in to their account.
HTTP Method:
POST
Endpoint URL:
https://cryptoaccesspro-backend.onrender.com/api/auth/login
Authentication:
No authentication required (login credentials provided in the request).
Request Data (JSON):
{ "email": "string (valid email format)", "password": "string (user's password)" } 
Response Data (Success - JSON):
{ "message": "Login successful", "token": "string (JWT token for user authentication)", "user": { "email": "string", "walletId": "string (UUIDv4)", "kycStatus": "string (e.g., pending, approved)" } } 
Error Handling:
• 400: Missing or invalid input (e.g., empty email/password fields)
• 401: Incorrect credentials (wrong email or password)
• 403: Account suspended
• 500: Server error
The frontend should display appropriate error messages (invalid credentials, account suspension, etc.).
Data Types:
• email: string
• password: string
• token: string (JWT token)
Sequential Calls:
• Upon successful login, the frontend should store the JWT token (usually in local storage) and redirect to /dashboard.

3. Access Fee Page (/access-fee)
Purpose:
Allows new users to pay the one-time $99.90 access fee to unlock the main features of the app.
HTTP Method:
POST
Endpoint URL:
https://cryptoaccesspro-backend.onrender.com/api/transactions/access-fee
Authentication:
JWT token (from login) is required to authenticate the user.
Request Data (JSON):
{ "amount": 99.90, "currency": "USD" } 
Response Data (Success - JSON):
{ "message": "Payment successful. Access granted.", "transactionId": "string (transaction reference)", "status": "paid", "user": { "email": "string", "walletId": "string", "accessStatus": "granted" } } 
Error Handling:
• 400: Invalid payment details (e.g., incorrect amount)
• 401: Authentication error (no JWT token or expired token)
• 402: Insufficient funds or failed payment transaction
• 500: Server error
The frontend should show error messages, such as payment failure or issues with the access fee, and guide the user to retry or contact support.
Data Types:
• amount: float
• currency: string (e.g., "USD")
• transactionId: string
• status: string ("paid")
Sequential Calls:
• After a successful payment, the frontend should update the user's accessStatus to "granted" and redirect to /dashboard.

4. Main Dashboard Page (/dashboard)
Purpose:
Displays the user's personalized dashboard, including wallet balances, investment options, and access to other features such as exchange, deposit, and withdrawal.
HTTP Method: GET
Endpoint URL: https://cryptoaccesspro-backend.onrender.com/api/dashboard
Authentication: JWT token (from login) is required.
Request Data: No additional data required, but the request must include the JWT token in the Authorization header (e.g., Bearer <your_jwt_token>).
Response Data (Success - JSON):
   {
  "user": {
    "email": "string",
    "walletId": "string (UUIDv4)",
    "balance": {
      "USD": "float",
      "BTC": "float",
      "ETH": "float"
      // Add other currencies as needed
    },
    "kycStatus": "string (pending, approved, rejected)",
    "accessStatus": "string (pending, granted)"
  },
  "investmentStatus": {
    "activePlans": [
      {
        "planId": "integer",
        "name": "string",
        "amountInvested": "float",
        "roi": "integer",
        "duration": "string",
        "status": "string (active, completed)"
      }
      // More active plans
    ],
    "availablePlans": [
      {
        "id": "integer",
        "name": "string",
        "minAmount": "float",
        "roi": "integer",
        "duration": "string"
      }
      // More available plans
    ]
  },
  "proPlusStatus": "string (active, inactive)"
}

Error Handling:
•    401: Unauthorized (invalid token)
•    403: Forbidden (e.g., user not allowed to access if access fee not paid)
•    500: Server error
The frontend should display appropriate error messages for any failed requests and guide users accordingly.
Data Types:
• email: string
• walletId: string (UUIDv4)
• balance: object with currency keys and float values
• kycStatus: string
• accessStatus: string
• investmentStatus: object containing investment plans
• proPlusStatus: string ("active" or "inactive")
Sequential Calls:
• After successful login and payment confirmation, the frontend should call this endpoint to display the user’s dashboard and navigate to different sections like Exchange, Investments, and Withdrawals.

5. Exchange Page (/exchange)
Purpose:
Allows users to simulate trading various cryptocurrency pairs using their virtual funds. Users can buy and sell cryptocurrencies.
HTTP Method:
GET (for loading available pairs)
POST (for making trades)
Endpoint URL:
• Get Available Pairs: https://cryptoaccesspro-backend.onrender.com/api/exchange/pairs
• Trade Transaction: https://cryptoaccesspro-backend.onrender.com/api/exchange/trade
Authentication:
JWT token (from login) is required for both actions (loading pairs and making trades).
Request Data (For GET request - available pairs): No request body required, but the request must include the JWT token for authentication.
Response Data (For GET request - Success - JSON):
{ "pairs": [ { "pair": "BTC/USD", "minAmount": "0.01", "maxAmount": "10", "price": "47000" }, { "pair": "ETH/USD", "minAmount": "0.1", "maxAmount": "50", "price": "3400" } ] } 
Request Data (For POST request - trade action):
{ "pair": "BTC/USD", "type": "buy", // or "sell" "amount": 0.5, // amount to buy/sell "price": 47000 // price at which the trade is executed } 
Response Data (For POST request - Success - JSON):
{ "transactionId": "123456", "pair": "BTC/USD", "amount": 0.5, "type": "buy", "price": 47000, "status": "successful", "newBalance": { "USD": 1000, "BTC": 1.5 } } 
Error Handling:
• 400: Invalid parameters (e.g., invalid currency pair, insufficient funds, etc.)
• 401: Unauthorized (invalid token)
• 403: Insufficient funds
• 500: Server error
The frontend should display appropriate error messages for invalid trades, insufficient funds, or server errors.
Data Types:
• pair: string (currency pair in the format "BASE/QUOTE")
• type: string ("buy" or "sell")
• amount: float (amount to buy/sell)
• price: float (price at which to buy/sell)
• transactionId: string
• status: string ("successful", "failed")
• newBalance: object containing updated wallet balances
Sequential Calls:
• The frontend first fetches available pairs via the GET /pairs endpoint.
• After selecting a pair and entering trade details, the frontend calls the POST /trade endpoint to simulate the transaction.

6. Investments Page (/investments)
Purpose:
Allows Pro+ users to participate in simulated investment plans. Users can view available investment plans and invest virtual funds.
HTTP Method:
GET (for fetching available investment plans)
POST (for making an investment)
Endpoint URL:
• Get Investment Plans: https://cryptoaccesspro-backend.onrender.com/api/investments/plans
• Make Investment: https://cryptoaccesspro-backend.onrender.com/api/investments/invest
Authentication:
JWT token (from login) is required for both actions (viewing plans and making investments).
Request Data (For GET request - available plans):
No request body required, but the request must include the JWT token for authentication.
Response Data (For GET request - Success - JSON):
{ "plans": [ { "id": 1, "name": "Plan A", "minAmount": 500, "roi": 20, "duration": "6 months" }, { "id": 2, "name": "Plan B", "minAmount": 1000, "roi": 25, "duration": "12 months" } ] } 
Request Data (For POST request - making an investment):
{ "planId": 1, // ID of the selected investment plan "amount": 500 // Amount to invest } 
Response Data (For POST request - Success - JSON):
{ "investmentId": "123456", "plan": "Plan A", "amount": 500, "roi": 20, "duration": "6 months", "status": "active", "startDate": "2025-05-01", "endDate": "2025-11-01" } 
Error Handling:
• 400: Invalid parameters (e.g., invalid plan, insufficient balance)
• 401: Unauthorized (invalid token)
• 403: Investment amount does not meet the minimum requirement
• 500: Server error
The frontend should display appropriate error messages for invalid investments, insufficient funds, or server errors.
Data Types:
• planId: integer (ID of the investment plan)
• amount: float (investment amount)
• investmentId: string (ID of the investment)
• roi: integer (return on investment percentage)
• startDate: string (date when the investment starts)
• endDate: string (date when the investment ends)
• status: string ("active", "completed")
• plan: string (name of the investment plan)
Sequential Calls:
• The frontend first fetches available investment plans via the GET /plans endpoint.
• After selecting a plan and entering an amount, the frontend calls the POST /invest endpoint to make the investment.

 Get Investment Details
 Purpose: Fetches detailed information about a specific investment belonging to the authenticated user.
 HTTP Method: GET
 Endpoint URL: /api/investments/:id (e.g., /api/investments/662f19f4a5d1c1abc1e9456a)
 Authentication: JWT token in the Authorization header. Header format: Authorization: Bearer <token>
 Request Data:
 Params:
•   id (string, required): Investment ID (MongoDB ObjectId)
•    No body is required.
 Response Data:
•    Format: application/json
•    Structure:
     {
  "success": true,
  "investment": {
    "_id": "string",
    "user": "string",
    "amount": "number",
    "plan": "string",
    "status": "string",       // e.g., "active", "cancelled", "completed"
    "startDate": "string",    // ISO date
    "endDate": "string",      // ISO date
    "roiHistory": [           // Optional, for ROI tracking
      {
        "date": "string",     // ISO date
        "amount": "number"
      }
    ],
    "createdAt": "string",
    "updatedAt": "string"
  }
}

 Error Handling:
•    404 Not Found: Investment doesn’t exist or doesn’t belong to the user. Frontend action: Display investment details screen or fallback with an error toast/message.
•    500 Internal Server Error: Unexpected failure – show a generic error message.
 Data Types:
•    id: string (MongoDB ObjectId)
•    amount: number (representing the invested amount)
•    plan: string (name or identifier of the investment plan)
•    status: string ("active" | "cancelled" | "completed")
•    roiHistory: Array of objects, where each object has:
•      date: string (ISO 8601 date)
•      amount: number (representing the ROI amount for that date)
•    startDate, endDate, createdAt, updatedAt: string (ISO 8601 date and time)
 Sequential Calls: This API is typically called when a user clicks on a specific investment listed on the Dashboard or within the Investments Tab (after the initial dashboard data or investment list is fetched).

Cancel Investment
 Purpose: Cancels a currently active investment for the authenticated user.
 HTTP Method: POST
 Endpoint URL: /api/investments/:id/cancel (e.g., /api/investments/662f19f4a5d1c1abc1e9456a/cancel)
 Authentication: JWT token in the Authorization header. Header format: Authorization: Bearer <token>
 Request Data:
   Params:
•      id (string, required): Investment ID (MongoDB ObjectId)
•    Body: None
 Response Data:
•    Format: application/json
•    * Structure:
     {
  "success": true,
  "message": "Investment cancelled",
  "investment": {
    "_id": "string",
    "status": "cancelled"
  }
}

 Error Handling:
•    404 Not Found: Investment does not exist or isn’t owned by the user. Frontend action: Refresh investment tab or notify the user with an error popup.
•    400 Bad Request: Investment already cancelled or completed. Frontend action: Notify the user that the investment cannot be cancelled.
•    500 Internal Server Error: Unexpected issue – display a fallback error message.
 Data Types:
•    id: string (MongoDB ObjectId)
•    status: string ("cancelled")
 Sequential Calls: This API is called when a user initiates the cancellation of an investment from the Investment Details screen or a similar interface. After a successful cancellation, the frontend might refresh the list of active investments (by calling the dashboard API or the investment list API again) or update the UI locally.

7. Charts Page (/charts?coin=...)
Purpose:
Allows users to view detailed charts of cryptocurrency prices over time. The charts display data for various cryptocurrencies, such as Bitcoin (BTC), Ethereum (ETH), etc. The page allows users to track market trends for their virtual assets.
HTTP Method:
GET
Endpoint URL:
https://cryptoaccesspro-backend.onrender.com/api/charts?coin={coinName}
Where {coinName} is the symbol of the cryptocurrency (e.g., BTC, ETH).
Authentication:
JWT token (from login) is required to access the charts page.
Request Data:
No request body required, but the request must include the JWT token for authentication and the cryptocurrency symbol (coin) as a query parameter.
Response Data (Success - JSON):
{ "coin": "BTC", "data": [ { "timestamp": "2025-05-01T00:00:00Z", "price": 50000.00 }, { "timestamp": "2025-05-02T00:00:00Z", "price": 50500.00 } // Additional data points ] } 
Error Handling:
• 400: Invalid coin symbol
• 401: Unauthorized (invalid token)
• 404: Coin data not found
• 500: Server error
The frontend should display appropriate error messages if the coin data is unavailable or the user is unauthorized.
Data Types:
• coin: string (the symbol of the cryptocurrency, e.g., "BTC")
• timestamp: string (ISO 8601 format date of the data point)
• price: float (price of the cryptocurrency at that timestamp)
Sequential Calls:
• The frontend first fetches data for the selected coin (e.g., GET /charts?coin=BTC).
• The data is processed and rendered in a chart or graph for visual representation.

8. Deposit Page (/dashboard > Deposit)
Purpose:
Allows users to view the deposit addresses for various cryptocurrencies to fund their virtual wallets. Users can request a deposit address for different coins, which they can use to send real funds to the app.
HTTP Method:
GET (to fetch the deposit address)
Endpoint URL:
https://cryptoaccesspro-backend.onrender.com/api/wallets/deposit-address?currency={currency}
Where {currency} is the cryptocurrency the user wants to deposit (e.g., BTC, ETH).
Authentication:
JWT token (from login) is required to access the deposit page.
Request Data:
• currency (query parameter): string (the cryptocurrency the user wants to deposit, e.g., BTC, ETH)
Response Data (Success - JSON):
{ "currency": "BTC", "depositAddress": "1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa" } 
Where:
• currency: string (the cryptocurrency the user wants to deposit)
• depositAddress: string (the unique wallet address for the user’s deposit)
Error Handling:
• 400: Invalid currency code
• 401: Unauthorized (invalid token)
• 404: Currency not supported for deposits
• 500: Server error
The frontend should display an appropriate error message if the currency is invalid, not supported, or there is a server issue.
Data Types:
• currency: string (the cryptocurrency symbol, e.g., "BTC")
• depositAddress: string (the generated deposit address)
Sequential Calls:
• The frontend requests the deposit address by calling GET /wallets/deposit-address?currency=BTC.
• The user sees the generated address for the selected currency.

9. Withdraw Page (/withdraw)
Purpose:
Allows Pro+ users (after admin approval and KYC verification) to initiate simulated withdrawal requests from their virtual wallet. Admin will later process these requests.
HTTP Method:
POST (to submit a withdrawal request)
Endpoint URL:
https://cryptoaccesspro-backend.onrender.com/api/wallets/withdraw
Authentication:
JWT token (from login) is required. Only Pro+ users with approved KYC status can access this endpoint.
Request Data:
• amount (body field): float (the amount the user wants to withdraw, in USD or virtual funds)
• currency (body field): string (the cryptocurrency the user wants to withdraw, e.g., BTC, ETH)
• address (body field): string (the destination wallet address for withdrawal)
Example JSON body:
{ "amount": 100, "currency": "BTC", "address": "1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa" } 
Response Data (Success - JSON):
{ "status": "success", "message": "Withdrawal request has been submitted and is pending approval.", "withdrawalId": "12345" } 
Where:
• status: string (confirmation that the request was successful)
• message: string (user-friendly message)
• withdrawalId: string (unique ID for tracking the withdrawal request)
Error Handling:
• 400: Invalid request data (e.g., insufficient balance or invalid address)
• 401: Unauthorized (if the user is not logged in or not Pro+)
• 402: Insufficient balance
• 403: KYC not approved (for non-Pro+ or unverified users)
• 500: Server error
The frontend should show appropriate messages for errors, such as insufficient funds or KYC pending.
Data Types:
• amount: float (the withdrawal amount, in USD or virtual currency)
• currency: string (cryptocurrency symbol, e.g., "BTC")
• address: string (wallet address for the withdrawal)
• status: string (response status, e.g., "success")
• message: string (response message, e.g., "Withdrawal request has been submitted.")
• withdrawalId: string (unique ID for the withdrawal)
Sequential Calls:
• User submits withdrawal request with POST /wallets/withdraw containing the amount, currency, and wallet address.
• Frontend shows a pending withdrawal message until the admin processes it.

10. Settings Page (/settings)
Purpose:
Allows users to manage their profile information, language preferences, and KYC status. This page gives users control over their account settings and personal details.
HTTP Method:
•    GET: To fetch current settings.
•    PATCH: To update settings.
Endpoint URL: https://cryptoaccesspro-backend.onrender.com/api/users/settings
Authentication: JWT token is required.
 Request Data (PATCH - JSON):
   {
  "name": "string (optional)",
  "email": "string (optional, valid email format)",
  "language": "string (optional, e.g., 'en', 'es')"
  // Add other settings fields as needed
}

 Response Data (Success - GET and PATCH - JSON):
   {
  "status": "success",
  "message": "Settings updated successfully.",
  "user": {
    "name": "string",
    "email": "string",
    "language": "string"
    // Include other relevant user settings
  }
}

 Error Handling:
•    400: Invalid data (e.g., invalid email format)
•    401: Unauthorized (invalid token)
•    500: Server error
The frontend should handle error scenarios by showing specific messages like "Invalid email format" or "Please log in."
Data Types:
• name: string (the user's name)
• email: string (the user's email)
• language: string (language preference code)
• status: string (response status, e.g., "success")
• message: string (response message, e.g., "Settings updated successfully.")
Sequential Calls:
• User submits PATCH /users/settings to update their settings (name, email, or language).
• Frontend shows confirmation that settings have been updated.

11. Profile Edit Page (/profile/edit)
Purpose:
Allows users to edit their personal profile information such as name, email, and other personal details. This page is a subset of the settings page, focused specifically on updating profile information.
HTTP Method:
•   GET: To fetch current profile information.
•   PATCH: To update profile details.
 Endpoint URL: https://cryptoaccesspro-backend.onrender.com/api/users/profile/edit
 Authentication: JWT token is required.
 Request Data (PATCH - JSON):
   {
  "name": "string (optional)",
  "email": "string (optional, valid email format)"
  // Add other profile fields as needed
}

 Response Data (Success - GET and PATCH - JSON):
   {
  "status": "success",
  "message": "Profile updated successfully.",
  "user": {
    "name": "string",
    "email": "string"
    // Include other relevant profile information
  }
}

 Error Handling:
•    400: Invalid data (e.g., invalid email format)
•    401: Unauthorized (invalid token)
•    500: Server error
The frontend should display appropriate messages such as "Invalid email format" or "Please log in to update your profile."
Data Types:
• name: string (the user's name)
• email: string (the user's email)
• status: string (response status, e.g., "success")
• message: string (response message, e.g., "Profile updated successfully.")
Sequential Calls:
• User submits PATCH /users/profile/edit with updated profile information (name, email).
• Frontend shows confirmation that the profile has been updated.

12. KYC Verification Page (/kyc)
Purpose:
This page allows users to submit their KYC (Know Your Customer) documents for verification. Users can upload their identification documents (e.g., passport, driver's license) and a selfie to verify their identity. The status of the verification process is also displayed.
HTTP Method:
GET (to fetch the current KYC status)
POST (to submit KYC documents)
Endpoint URL:
GET /api/kyc/status - Check current KYC status
POST /api/kyc/submit - Submit KYC documents
Authentication:
JWT token required for the user. Only authenticated users can submit KYC documents and view their status.
Request Data (POST - when submitting KYC documents):
• id_document (form data): file (e.g., passport or driver's license in JPEG/PNG/PDF format, max 5MB)
• selfie (form data): file (selfie in JPEG/PNG format, max 5MB)
Example request data for document submission (in form-data format):
id_document: [file] selfie: [file] 
Response Data (POST - Success - JSON):
{ "status": "success", "message": "KYC documents submitted successfully. Awaiting admin review." } 
Where:
• status: string (confirmation of success)
• message: string (user-friendly confirmation message)
Response Data (GET - KYC Status - JSON):
{ "status": "pending", "message": "KYC verification is pending. Please wait for admin approval." } 
Where:
• status: string (KYC status: "pending", "approved", "rejected")
• message: string (user-friendly message regarding KYC status)
Error Handling:
• 400: Invalid file format or file too large
• 401: Unauthorized (if the user is not logged in)
• 404: KYC documents not found for the user (when checking KYC status)
• 500: Server error
The frontend should display messages like "Please upload a valid passport or driver's license" or "Your selfie must be less than 5MB."
Data Types:
• id_document: file (passport, driver's license)
• selfie: file (selfie image)
• status: string (e.g., "pending", "approved", "rejected")
• message: string (e.g., "KYC verification is pending.")
Sequential Calls:
• User uploads documents via POST /api/kyc/submit with ID document and selfie.
• The backend processes and stores the documents while setting kycStatus: pending.
• Admin reviews the documents via a separate backend process (admin panel).
• User can check the KYC status via GET /api/kyc/status.

13. Pro+ Upgrade Page (/pro-plus)
Purpose:
This page allows users to pay the one-time fee to upgrade to the Pro+ tier. Once users complete the payment, they will gain access to additional features such as the Investment Plans, withdrawal functionalities, and more. After payment, the user’s status is updated to Pro+.
HTTP Method:
GET (to fetch Pro+ upgrade details)
POST (to process Pro+ upgrade payment)
Endpoint URL:
GET /api/plans/pro-plus - Fetch Pro+ upgrade details
POST /api/plans/upgrade-pro-plus - Submit Pro+ upgrade request
Authentication:
JWT token required for the user. Only authenticated users can access the Pro+ upgrade process.
Request Data (POST - when upgrading to Pro+):
• payment_method (string): payment method used (e.g., "crypto" or "wallet balance")
• payment_details (object): details of the payment transaction (e.g., transaction hash if paying with crypto)
Example request data for Pro+ upgrade:
{ "payment_method": "crypto", "payment_details": { "transaction_hash": "abcdef123456" } } 
Response Data (POST - Success - JSON):
{ "status": "success", "message": "Pro+ upgrade successful. You now have access to premium features." } 
Where:
• status: string (confirmation of success)
• message: string (user-friendly confirmation message)
Response Data (GET - Pro+ Details - JSON):
{ "price": 299.99, "currency": "USD", "description": "Upgrade to Pro+ for full access to premium features like Investment Plans and Withdrawals." } 
Where:
• price: number (price of the Pro+ upgrade)
• currency: string (currency for payment)
• description: string (details about the Pro+ upgrade)
Error Handling:
• 400: Invalid payment details (e.g., wrong transaction hash, invalid payment method)
• 401: Unauthorized (if the user is not logged in)
• 402: Insufficient balance (if paying with wallet balance and the balance is too low)
• 500: Server error
The frontend should display messages like "Please ensure your payment method is valid" or "Insufficient funds to upgrade to Pro+".
Data Types:
• payment_method: string (e.g., "crypto", "wallet balance")
• payment_details: object (e.g., { "transaction_hash": "abcdef123456" })
• price: number (USD value of the Pro+ upgrade)
• currency: string (currency code like "USD")
• description: string (description of Pro+ features)
Sequential Calls:
• User navigates to /pro-plus to see details about the Pro+ upgrade.
• User submits payment details via POST /api/plans/upgrade-pro-plus.
• The backend processes the payment and updates the user's status to Pro+.
• The user gains access to Pro+ features.

14. Referrals Page (/referrals)
Purpose:
This page displays the user’s referral information, including their referral code, the number of users they have referred, and possibly a referral leaderboard or incentive information. Users can also share their referral code with others to earn rewards based on the number of successful sign-ups or upgrades.
HTTP Method:
• GET: To fetch the user's referral information.
• POST: To potentially handle sharing actions (could be generating a shareable link or sending an email).
Endpoint URL:
•    GET /api/referrals
•    POST /api/referrals/share
 Authentication: JWT token is required for both.
 Request Data (POST - JSON - Optional, depending on sharing method):
   {
  "recipient_email": "string (optional, valid email format)"
  // Add other sharing parameters if needed (e.g., platform)
}

 Response Data (GET - Success - JSON):
   {
  "referral_code": "string",
  "total_referrals": "integer",
  "referred_users": [
    {
      "email": "string",
      "signupDate": "string (ISO 8601 format)",
      "status": "string (active, Pro+)"
      // Add other relevant details about referred users
    }
    // More referred users
  ],
  "referralLink": "string (optional, the generated referral link)"
  // Include any referral rewards information if applicable
}

 Response Data (POST - Success - JSON):
   {
  "status": "success",
  "message": "Referral link shared successfully."
}

 Error Handling:
•    400: Invalid referral link or recipient details
•    401: Unauthorized (invalid token)
•    500: Server error
The frontend should display messages like "Error sending referral link" or "Please enter a valid email address."
Data Types:
• referral_code: string (user's unique referral code)
• total_referrals: integer (number of users referred)
• referred_users: array of objects (e.g., { "email": "user1@example.com", "status": "active" })
• recipient_email: string (email address of the referral recipient)
Sequential Calls:
• User navigates to /referrals to view their referral code and statistics.
• If they want to share their referral link, they submit the recipient's email via POST /api/referrals/share.
• The backend processes the referral link sharing and sends the link to the provided email address.
• The user may earn rewards based on how many users sign up or upgrade through their referral code.

15. Logout (Handled from Header/User Dropdown)
Purpose:
This action allows users to securely end their session and log out from the application. It’s typically triggered from a user dropdown in the app header, not a standalone page.
HTTP Method:
POST or GET (depending on how token/session handling is implemented)
Endpoint URL:
POST /api/logout (optional, if session is stored server-side)
If token-based (e.g., JWT): simply delete the token client-side
Authentication:
Only accessible if the user is logged in (auth token exists).
Request Data:
No request body is typically needed unless sessions are invalidated on the server.
Frontend Action (Client-Side):
localStorage.removeItem('token'); router.push('/login'); 
Backend Action (Optional - for session-based logout): If sessions or refresh tokens are stored on the server, you might invalidate them:
{ "status": "success", "message": "Logged out successfully." } 
Error Handling:
• If logout token/session doesn't exist, ignore and redirect to login.
• Always ensure redirection to /login after logout.
Security:
• Clear all auth tokens and user data from localStorage/sessionStorage/cookies.
• Redirect user immediately after logout.
• Optionally show a toast/snackbar saying "You have been logged out."

Admin side 
1. /admin/login
 * Purpose: Authenticate admin users and establish an admin session.
 * HTTP Method: POST
 * Endpoint URL: /admin/login
 * Authentication: None (this endpoint is for authentication itself).
 * Request Data:
   * Format: JSON
   * Structure:
     {
  "email": "string",
  "password": "string"
}

   * Data Types:
     * email: string (valid email format for admin users)
     * password: string (admin user's password)
 * Response Data:
   * Format: JSON
   * Structure:
     {
  "success": true,
  "user": {
    "id": "string",
    "email": "string"
  }
}

   * Data Types:
     * success: boolean
     * user: object
       * id: string (unique identifier for the admin user)
       * email: string (email address of the authenticated admin user)
 * Error Handling:
   * 429 (Too Many Requests): Display a message indicating rate limiting and advise the user to try again later.
   * 403 (Forbidden): Display a message indicating invalid credentials (incorrect email or password).
   * 500 (Internal Server Error): Display a generic error message indicating a server issue and advise the user to try again or contact support.
 * Sequential Calls: This is the initial login call; subsequent admin actions will require the adminToken cookie.
2. /admin/logout
 * Purpose: Terminate the current admin session.
 * HTTP Method: POST
 * Endpoint URL: /admin/logout
 * Authentication: JWT Cookie (adminToken).
 * Request Data: None (typically the authentication is handled via the cookie).
 * Response Data:
   * Format: JSON
   * Structure:
     {
  "success": true,
  "message": "Admin logged out successfully."
}

   * Data Types:
     * success: boolean
     * message: string
 * Error Handling:
   * 401 (Unauthorized): Redirect the admin to the login page as the session might already be invalid or the cookie is missing.
   * 500 (Internal Server Error): Display a generic error message indicating a server issue.
 * Sequential Calls: This is usually the final call when an admin wants to end their session. After this, the frontend should clear any local admin session data (if any) and redirect to the login page.
3. /admin/users (GET)
 * Purpose: Retrieve a list of users, with optional filters (e.g., status).
 * HTTP Method: GET
 * Endpoint URL: /admin/users?status=pending&isProPlus=true&page=1 (example with query parameters for filtering and pagination)
 * Authentication: JWT Cookie (adminToken).
 * Request Data: Query parameters in the URL for filtering and pagination:
   * status: string (optional, e.g., "pending", "active", "suspended")
   * isProPlus: boolean (optional, filter by Pro+ status)
   * kycStatus: string (optional, e.g., "pending", "approved", "rejected")
   * page: integer (optional, page number for pagination)
   * (Other filter parameters might be applicable)
 * Response Data:
   * Format: JSON
   * Structure:
     {
  "success": true,
  "users": [
    {
      "id": "string",
      "email": "string",
      "kycStatus": "enum",
      "isProPlus": "boolean",
      "isSuspended": "boolean",
      "walletId": "string",
      "balances": {
        "BTC": "number",
        "ETH": "number",
        "USDT": "number"
        // ... other currencies
      },
      "registrationDate": "string (ISO 8601 format)"
      // ... other user details
    },
    // ... more user objects
  ],
  "totalCount": "integer",
  "totalPages": "integer"
}

   * Data Types: See Data Types Specification in your documentation for individual fields.
 * Error Handling:
   * 401 (Unauthorized): Redirect to admin login.
   * 500 (Internal Server Error): Display a generic error message.
 * Sequential Calls: This call is typically made to initially load the user list or when applying filters or navigating pages.
4. /admin/approve-user (PATCH)
 * Purpose: Approve a pending user registration.
 * HTTP Method: PATCH
 * Endpoint URL: /admin/approve-user
 * Authentication: JWT Cookie (adminToken).
 * Request Data:
   * Format: JSON
   * Structure:
     {
  "email": "string"
}

   * Data Types:
     * email: string (email address of the user to approve)
 * Response Data:
   * Format: JSON
   * Structure:
     {
  "success": true,
  "user": {
    // Full user object after approval
    "id": "string",
    "email": "string",
    "kycStatus": "enum",
    "isProPlus": "boolean",
    "isSuspended": "boolean",
    "walletId": "string",
    "balances": { /* ... */ },
    "registrationDate": "string"
    // ... other user details, now potentially updated
  }
}

   * Data Types: See Data Types Specification.
 * Error Handling:
   * 400 (Bad Request): Display a message indicating invalid input (e.g., missing email).
   * 401 (Unauthorized): Redirect to admin login.
   * 404 (Not Found): Display a message indicating that the user with the provided email was not found.
   * 500 (Internal Server Error): Display a generic error message.
 * Sequential Calls: Typically follows fetching the list of pending users (GET /admin/users?status=pending). After approval, the frontend might refresh the user list or fetch the updated user details.
5. /admin/suspend-user (PATCH)
 * Purpose: Suspend or unsuspend a user account.
 * HTTP Method: PATCH
 * Endpoint URL: /admin/suspend-user
 * Authentication: JWT Cookie (adminToken).
 * Request Data:
   * Format: JSON
   * Structure:
     {
  "email": "string",
  "isSuspended": "boolean"
}

   * Data Types:
     * email: string (email address of the user to suspend/unsuspend)
     * isSuspended: boolean (true to suspend, false to unsuspend)
 * Response Data:
   * Format: JSON
   * Structure:
     {
  "success": true,
  "user": {
    "id": "string",
    "email": "string",
    "isSuspended": "boolean" // Updated status
    // ... other relevant user details
  }
}

   * Data Types: See Data Types Specification.
 * Error Handling:
   * 400 (Bad Request): Display a message indicating invalid input (e.g., missing email or isSuspended flag).
   * 401 (Unauthorized): Redirect to admin login.
   * 404 (Not Found): Display a message indicating that the user with the provided email was not found.
   * 500 (Internal Server Error): Display a generic error message.
 * Sequential Calls: Usually follows viewing the user list. The frontend might refresh the list or update the specific user's UI after this action.
6. /admin/users/:id (DELETE)
 * Purpose: Permanently delete a user account.
 * HTTP Method: DELETE
 * Endpoint URL: /admin/users/{id} (where {id} is the unique identifier of the user)
 * Authentication: JWT Cookie (adminToken).
 * Request Data: None (the user's ID is in the URL path).
 * Response Data:
   * Format: JSON
   * Structure:
     {
  "success": true,
  "message": "User deleted successfully."
}

   * Data Types:
     * success: boolean
     * message: string
 * Error Handling:
   * 401 (Unauthorized): Redirect to admin login.
   * 404 (Not Found): Display a message indicating that the user with the provided ID was not found.
   * 500 (Internal Server Error): Display a generic error message.
 * Sequential Calls: Typically follows viewing user details or the user list. After deletion, the frontend should refresh the user list or navigate away from the deleted user's details page.
7. /admin/grant-pro-plus (PATCH)
 * Purpose: Manually grant a Pro+ subscription to a user.
 * HTTP Method: PATCH
 * Endpoint URL: /admin/grant-pro-plus
 * Authentication: JWT Cookie (adminToken).
 * Request Data:
   * Format: JSON
   * Structure:
     {
  "email": "string"
}

   * Data Types:
     * email: string (email address of the user to grant Pro+ to)
 * Response Data:
   * Format: JSON
   * Structure:
     {
  "success": true,
  "user": {
    "id": "string",
    "email": "string",
    "isProPlus": true // Updated status
    // ... other relevant user details
  }
}

   * Data Types: See Data Types Specification.
 * Error Handling:
   * 400 (Bad Request): Display a message indicating invalid input (e.g., missing email).
   * 401 (Unauthorized): Redirect to admin login.
   * 404 (Not Found): Display a message indicating that the user with the provided email was not found.
   * 500 (Internal Server Error): Display a generic error message.
 * Sequential Calls: Usually follows viewing user details or the user list. The frontend should update the user's Pro+ status in the UI after this action.
8. /admin/bypass-payment (PATCH)
 * Purpose: Bypass the payment requirement (e.g., access fee, Pro+ upgrade) for a specific user.
 * HTTP Method: PATCH
 * Endpoint URL: /admin/bypass-payment
 * Authentication: JWT Cookie (adminToken).
 * Request Data:
   * Format: JSON
   * Structure:
     {
  "email": "string",
  "paymentType": "access_fee|pro_plus" // Specify which payment to bypass
}

   * Data Types:
     * email: string (email address of the user)
     * paymentType: string (either "access_fee" or "pro_plus")
 * Response Data:
   * Format: JSON
   * Structure:
     {
  "success": true,
  "user": {
    "id": "string",
    "email": "string",
    "accessStatus": "string (potentially updated to 'granted')",
    "isProPlus": "boolean (potentially updated to true)"
    // ... other relevant user details
  }
}

   * Data Types: See Data Types Specification.
 * Error Handling:
   * 400 (Bad Request): Display a message indicating invalid input (e.g., missing email or paymentType).
   * 401 (Unauthorized): Redirect to admin login.
   * 404 (Not Found): Display a message indicating that the user with the provided email was not found.
   * 500 (Internal Serve


==========≈==========
use this to connect it this will guide you 

I. Global Navigation & Header:
 * Fixed Top Navbar:
   * Logo: "CryptoAccess Pro" (top-left)
   * Navigation Options (Right-aligned):
     * /About: Navigates to a dedicated "About CryptoAccess Pro" page.
     * Language Selector: Dropdown for multilingual support.
     * Signup: Likely a button or link that navigates to the /signup form.
 * User Dropdown (Top-right of Dashboard):
   * Profile: Navigates to /profile/edit or /settings.
   * Settings: Navigates to /settings.
   * Logout: Triggers the logout functionality.
II. Main Pages & Sections (User Side):
 * Splash/Welcome Page:
   * Language Selector (prominent on initial entry).
   * Potentially a brief visual introduction to the app.
 * Home Page (/) (After Login & Access Fee):
   * Hero Section (First Fold):
     * Engaging Title & Subtext.
     * "Get Started" Button (scrolls to /signup initially, might change for logged-in users).
     * Animated Background (SVG, gradient, crypto icons).
     * Scrollable User Reviews (Carousel).
     * "WHAT WE OFFER" Section (Feature Blocks):
       * WALLETS
       * PRO INVESTMENTS
       * ADVANCED EXCHANGE
       * BUSINESS
       * DEVELOPERS
       * CUSTOMER SUPPORT
     * "Built on Experience You Can Trust" Section.
     * "Hear From Our Users" Section (Testimonials).
     * "And That’s Just The Beginning..." Section.
     * "Secure, Fast, Ready Anywhere" Section.
   * Footer:
     * Copyright Information.
     * Terms & Conditions (link).
     * Privacy Policy (link).
     * Contact (link).
     * Social Icons.
 * /signup Page:
   * Signup Form (First Name, Last Name, Email, Password).
   * "Already have an account?" link to /login.
 * /login Page:
   * Login Form (Email, Password, Remember Me).
   * "Forgot password?" link (optional).
   * "New here?" link to /signup.
 * /access-fee Page:
   * Header Section (Title, Subtitle, Subtext).
   * Payment Wallet Grid (Cards for each supported crypto with address, QR, and copy).
   * Fake MoonPay/Transak Card Options (disabled).
   * "I Have Paid" Button.
   * Support Section (email with copy button).
 * /dashboard Page (Main User Dashboard):
   * Header Navigation (as described in Global Navigation).
   * Tabs (Below Header):
     * Dashboard (Default landing page)
     * Exchange (/exchange)
     * Investments (/investments) (Pro+ Only - Conditional Visibility)
     * Charts (/charts)
     * Support
     * Profile
   * Virtual Wallet Cards Overview Section: Responsive grid/horizontal scroll of individual wallet cards.
   * Deposit / Buy Section:
     * Header Title.
     * Deposit Card Grid (crypto addresses and QR codes).
     * Fake MoonPay/Transak Card Payment Cards (disabled).
     * Sticky "I Have Paid" Button.
   * Floating Help Button (Optional): Links to support email.
 * /exchange Page (Fake Trading System):
   * Top Navigation: Search Bar for trading pairs.
   * Trading Pairs List: Scrollable list of simulated crypto pairs.
   * Trading View Layout (Mimics Binance):
     * Simulated Live Chart Area (with style dropdown and timeframe tabs).
     * Trade Panel (Buy/Sell tabs with price, amount, total, submit buttons).
     * Fake Order History (client-side).
 * /investments Page (Pro+ Users Only):
   * Header Section (Title, Subtitle).
   * Investment Form (Interactive Card Interface):
     * Step 1: Choose Investment Amount (input with auto-convert and validation).
     * Step 2: Select Currency (dropdown with balance display).
     * Step 3: Invest Button (confirmation modal).
   * Current Investments Display (Card Grid): Details of active/completed investments.
   * ROI Payout Tracker (Progress bar with milestones).
   * Investment History (Table/scrollable list).
   * Admin Approval Notes (Optional Overlay for pending investments).
 * /charts Page:
   * Fake price chart (candlesticks or bars).
   * Buy / Sell input fields.
   * Fake "Market Order" button.
 * /settings Page:
   * Top Section (Sticky Header): Title, Back/Menu, Language/Avatar.
   * Profile Settings Card (links to /profile/edit).
   * Language Selector (modal or dropdown).
   * KYC Verification Section (links to /kyc).
   * Security Settings (fake 2FA toggle, notification preferences).
   * Logout (button at the bottom).
 * /profile/edit Page (Within Settings):
   * Form with editable profile fields (First Name, Last Name, Phone, Email (readonly), Country, DOB, Preferred Currency).
   * Survey Additions (dropdowns/radio buttons).
   * Save Button (bottom-anchored).
   * Security Notice.
 * /kyc Page (Within Settings):
   * Step-by-step form for KYC submission:
     * Full Name (auto-filled).
     * Date of Birth.
     * Country of Residence.
     * ID Type (dropdown).
     * Upload fields (Front of ID, Back of ID (optional), Selfie).
     * "Submit KYC" and "Cancel" buttons.
 * /pro-plus Page:
   * Top Section (Header): Title, Description, Pro+ icon/badge, Subtitle.
   * Main Section (Crypto Wallet Payment UI): Scrollable list of crypto wallets with addresses and copy.
   * Fake Fiat On-Ramp Options (Greyed out).
   * "I Have Paid" Confirmation Button.
 * /referrals Page (Within Settings):
   * Header Section (Title, Subtitle).
   * User Referral Summary: Referral Code (with copy), Referral Link (with copy).
   * Referral Stats Panel (Cards/grid): Total Referrals, Total Earned, Pending, Approved.
   * How It Works (Expandable/Accordion).
   * Share Buttons (Social media, copy link).
   * Support Info (clickable email with copy).
   * "I Have Paid" Confirmation Button (if applicable to referral rewards).
 * /withdraw Page (Pro+ & KYC Approved Only):
   * Header Section (Title, Notice).
   * Wallet Selector Dropdown (with balances).
   * Amount Input (with optional slider).
   * Real Wallet Address Input (required, optional QR scan).
   * Network Type Selector (dropdown for multi-network coins).
   * Withdrawal Summary Box.
   * "Submit Withdrawal Request" Button.
   * Withdrawal Rules / Notices.
   * Support CTA (email with copy).
   * Withdrawal History Table.
III. Conditional Visibility:
 * Investments Tab: Only visible for Pro+ users (user.isProPlus === true).
 * Withdraw Tab: Only visible for Pro+ users AND users with approved KYC (user.isProPlus === true && user.isKYCApproved === true).
IV. Modals and Toasts:
 * Email verification success message.
 * Copy to clipboard confirmation.
 * "Currently unavailable" for MoonPay/Transak.
 * "Waiting for admin confirmation..." after "I Have Paid".
 * Trade successful/failed messages.
 * Investment confirmation.
 * KYC submission confirmation.
 * Logout confirmation.
 * Error messages (login, signup, etc.).
V. Recurring UI Elements:
 * Binance-style design language (colors, fonts, spacing, shadows).
 * Smooth transitions between pages and sections.
 * Animated buttons and interactive elements.
 * Mobile-responsive layouts for all pages.
 * "Need help?" support link/button (likely in the footer or as a floating action button).

 Admin Panel Routes & Sections:
 * /admin/login Page: (Previously described)
 * /admin/logout Page: (Previously described)
 * /admin/dashboard Page: (Previously described - will likely use data fetched from various admin API endpoints)
 * /admin/users Page: (Previously described - now we know it will likely use the GET /admin/users endpoint)
 * /admin/kyc Page:
   * Interface to view users needing KYC verification (likely using GET /admin/users?kycStatus=pending).
   * Links or UI elements to view individual KYC documents (using GET /admin/kyc-docs/:userId).
   * Actions to approve or reject KYC (using PATCH /admin/verify-kyc).
 * /admin/withdrawals Page:
   * Displays pending withdrawal requests (using GET /admin/withdrawals/pending).
   * Allows admins to approve, reject, or mark withdrawals as complete (using PATCH /admin/withdrawals/:id).
 * /admin/wallets Page:
   * Form to view current admin wallet addresses (using GET /api/admin/settings/wallets).
   * Form to update admin wallet addresses (using PUT /api/admin/settings/wallets).
 * /admin/logs Page:
   * Displays audit logs (using GET /api/admin/settings/logs).
   * Likely with filtering and pagination options.
 * /admin/notifications Page:
   * Displays previously sent notifications (using GET /api/admin/settings/notifications).
   * Form to create and send new notifications to users (using POST /api/admin/settings/notifications).
 * /admin/settings Page (Platform-Wide):
   * Form to view current platform settings (fees, limits, toggles) (using GET /api/admin/settings/settings).
   * Form to update platform settings (using PUT /api/admin/settings/settings).



just put and Match these functions below to the admin side above 

Key Administrative Functions and Corresponding Endpoints:
 * User Management:
   * View Users: GET /admin/users
   * Approve User: PATCH /admin/approve-user
   * Suspend/Unsuspend User: PATCH /admin/suspend-user
   * Delete User: DELETE /admin/users/:id
   * Grant Pro+: PATCH /admin/grant-pro-plus
   * Bypass Payment: PATCH /admin/bypass-payment
   * Update Balance: PATCH /admin/update-balance
   * Send Funds: POST /admin/send-funds
   * Adjust Balance: PATCH /admin/adjust-balance
   * Verify Email: PATCH /admin/verify-email
 * KYC Management:
   * View Pending KYC: GET /admin/users?kycStatus=pending
   * View KYC Documents: GET /admin/kyc-docs/:userId
   * Approve/Reject KYC: PATCH /admin/verify-kyc
 * Withdrawal Management:
   * View Pending Withdrawals: GET /admin/withdrawals/pending
   * Approve/Reject/Complete Withdrawal: PATCH /admin/withdrawals/:id
 * Wallet Management:
   * View Admin Wallets: GET /api/admin/settings/wallets
   * Update Admin Wallets: PUT /api/admin/settings/wallets
 * System Management:
   * View Logs: GET /api/admin/settings/logs
   * View Notifications: GET /api/admin/settings/notifications
   * Send Notifications: POST /api/admin/settings/notifications
   * View Platform Settings: GET /api/admin/settings/settings
   * Update Platform Settings: PUT /api/admin/settings/settings
   * Trigger ROI Payouts: POST /admin/process-payouts

===≈===================
now remember you can add a prompt about the box that has now been added for access fees and pro+ subscriptions, where users can show proof of payment.

